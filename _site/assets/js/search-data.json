{"0": {
    "doc": "Contact us",
    "title": "Contact us",
    "content": "This website was created by Sreejith Santhosh , who is a graduate student at the Serra Group at UC San Diego. In case of any issues or queries regarding the code or the contents of this website, please reach out to Sreejith Santhosh or Mattia Serra. We will try to reply back to your emails ASAP. ",
    "url": "/docs/Contact.html",
    
    "relUrl": "/docs/Contact.html"
  },"1": {
    "doc": "FTLE on Curved Surfaces",
    "title": "Pre-requisites",
    "content": "The code was built on MATLAB R2023a in a Windows 10 system. The following MATLAB add-ons need to be installed to run the code, . | Parallel Computing Toolbox : The code uses parallelization methods provided in this toolbox to run the advection of tracer particles, | Lidar Toolbox : Provides mesh processing capabilities, | Computer Vision Toolbox : Provides mesh processing capabilities. | . We have tested these codes on a Mac OSX 15 and Ubuntu 20 operating systems. We also assume that Git is installed and set up on the system, as all the code is hosted on GitHub. If not, we refer you to this link. ",
    "url": "/docs/Tutorials/FTLECurvedSurface.html#pre-requisites",
    
    "relUrl": "/docs/Tutorials/FTLECurvedSurface.html#pre-requisites"
  },"2": {
    "doc": "FTLE on Curved Surfaces",
    "title": "Installation",
    "content": "To install the code, navigate to the path where you would want to install it on the terminal and clone the GitHub repository using the code . git clone https://github.com/SreejithSanthosh/curvedSurfaceFTLE.git . This will generate a directory called curvedSurfaceFTLE, which contains all the code. To check if all the necessary components are working, run main.m on MATLAB. This runs the deformation analysis on an example dataset of motion of cells on the pancreatic spheroids given in ./Data/staticMesh.mat and presents the following result, . In addition, the visualization of the velocity field, forward and backward advection of tracer particles would be given in /saveResults directory as vizVelocity.mp4 , forAdvct.mp4, and bckAdvct.mp4 respectively. Further development of this code is currently ongoing to improve the robustness of the method and increase its speed. To get those updates, use the command . git pull . ",
    "url": "/docs/Tutorials/FTLECurvedSurface.html#installation",
    
    "relUrl": "/docs/Tutorials/FTLECurvedSurface.html#installation"
  },"3": {
    "doc": "FTLE on Curved Surfaces",
    "title": "Data required for Langrangian analaysis and Formating",
    "content": "To perform the Lagrangian analysis, we require the velocity field \\(\\mathbf{v}(\\mathbf{x},t)\\) that quantifies the material flow on a manifold \\(\\mathbf{x} \\in \\mathcal{M}(t)\\). The Lagrangian Analysis method that we describe here works well for both static surfaces, where the manifold on which the flow happens is time-independent, and dynamic surfaces, where the manifold on which the flow happens is time-dependent. NOTE: Obtaining velocity data from tissue mechanics and active nematic simulations is relatively simple, but obtaining them from experimental live imaging of biological systems is more difficult. Several methods exist to extract this information, such as ImSAnE and TubULAR. The manifold information \\(\\mathcal{M}\\) is stored as a mesh with discrete node points \\(\\mathbf{x}_i = [x_i,y_i,z_i] \\in \\mathcal{R}^3\\) , where \\(i \\in \\{1,N_p(t)\\}\\) and \\(N_p(t)\\) is total number of nodes on the manifold at time \\(t\\). The connectivity of the mesh is given by a triangulation \\(T\\) which is a set of all the mesh faces, [THIS FOLLOWING SENTENCE IS UNCLEAR (SPLIT IT IN A STANDALONE SENTENCE)] which for say face \\(i \\in \\{1,N_f(t)\\}\\) would be another set of three vertices \\(\\{i_1,i_2,i_3\\}\\) where \\(i_1,i_2,i_3 \\in \\{1,N_p(t)\\}\\) are the indices of the nodes that form face \\(i\\), where \\(N_f(t)\\) is the total number of faces on the mesh at time \\(t\\). The velocity field is stored as \\(\\mathbf{v}_i(t) = [v_i^1(t),v_i^2(t),v_i^3(t)]\\) where \\(v_i^1(t),v_i^2(t)\\) and \\(v_i^3(t)\\) are the x,y and z-component of the velocity at node \\(i\\) at time \\(t\\). Before you run the Lagrangian analysis, the velocity field data and the manifold on which it is defined need to be stored in a .mat file to be read by the MATLAB code, where the variables are . | x : cell array of size (\\(N_t,1\\)), where the cell array element x{i} \\(i\\in \\{1,N_t\\}\\) is a double array of size \\((N_p(i),1)\\) with the x-coordinate \\(x_i\\) of all the mesh nodes, where \\(N_p(i)\\) is the total number of points on the manifold at \\(t = i\\). | y : cell array of size (\\(N_t,1\\)), where the cell array element y{i} \\(i\\in \\{1,N_t\\}\\) is a double array of size \\((N_p(i),1)\\) with the y-coordinate \\(y_i\\) of all the mesh nodes, where \\(N_p(i)\\) is the total number of points on the manifold at \\(t = i\\). | z : cell array of size (\\(N_t,1\\)), where the cell array element z{i} \\(i\\in \\{1,N_t\\}\\) is a double array of size \\((N_p(i),1)\\) with the z-coordinate \\(z_i\\) of all the mesh nodes, where \\(N_p(i)\\) is the total number of points on the manifold at \\(t = i\\). [THROUGHOUT: MAKE SURE THE NOTATION IS CONSISTENT WITH THE PAPER] . | TrianT : cell array of size (\\(N_t,1\\)), where the cell array element TrianT{i} \\(i\\in \\{1,N_t\\}\\) is a double array of size \\((N_f(i),3)\\) with mesh connectivity (For example, \\([i_1,i_2,i_3]\\) for a mesh face with nodes \\(i_1,i_2\\) and \\(i_3\\)) are appended along the rows, where \\(N_f(i)\\) is the total number of mesh faces on the manifold at \\(t = i\\). [THIS SENTENCE IS NOT GRAMATICALLY CORRECT] . | time : double array of size (\\(1,N_t\\)), which stores time information . | v : cell array of size (\\(3, N_t\\)) , where the cell array element v{1,i} \\(i\\in \\{1,N_t\\}\\) is a double array of size \\((N_p(i),1)\\) with the x-coodinate of the velocity \\(v^1_i\\) of all the mesh nodes, where \\(N_p(i)\\) is the total number of points on the manifold at \\(t = i\\). Similarly, the y and z components of the velocity are stored in v{2,i} and v{3,i}. | . An example dataset is given in ./Data/staticMesh.mat in the code directory, which can be visualized by running the code ./Data/vizExampleData.m. NOTE: An accurate Lagrangian Analysis requires that the mesh representation of the manifold is sampled uniformly, whereby the mesh faces are approximately of equal size; deviation from this may result in spurious results. The finer the mesh faces, the better the accuracy of the advection and deformation computed. If the original data does not meet this requirement, remeshing is recommended. ",
    "url": "/docs/Tutorials/FTLECurvedSurface.html#data-required-for-langrangian-analaysis-and-formating",
    
    "relUrl": "/docs/Tutorials/FTLECurvedSurface.html#data-required-for-langrangian-analaysis-and-formating"
  },"4": {
    "doc": "FTLE on Curved Surfaces",
    "title": "Performing Lagrangian Analysis",
    "content": "We now explain how to run the code main.m to compute the Lagrangian deformation information for a chosen time interval \\([t_0,t_f]\\). | Load the data : Once the data is formatted appropriately as mentioned in Data Formatting, it can be loaded onto the script by providing the right path load(PATH TO THE DATA FILE); Nt = size(time,2); . | Setting parameters for the simulation : There are a few parameters that need to be set depending on the type of data and the system configuration on which you are running the script, as described below . | isStatic : should be set to isStatic = 1 if the mesh surface on which the motion happens is time-independent and isStatic = 0 if the mesh changes over time. The code runs considerably faster for static meshes. | cpu_num : The code parallelizes the Lagrangian analysis using the parfor method. Therefore, set this variable to cpu_num = Nc, where \\(Nc\\) is the number of CPU cores available. Note that a copy of the dataset goes to each core, whereby the total data that exists in the RAM might exceed the systemâ€™s capabilities. For example, if your data is x GB and you parallelize over Nc cores, the total RAM required is \\(\\approx\\) &gt; x * Nc GB. | Plotting parameters Nplot and fntSz: Nplot sets the number of frames that are saved in the video while plotting the advection results. fntSz similarly sets the font size of the text and elements on those plots | Advection parameters ct_f and ct_i and dt: If you need to analyze the Lagrangian deformation from \\(t = t0\\) to \\(t = tf\\), input ct_f and ct_i so that time(ct_f) = tf and time(ct_0) = t0. The parameter dt is the time-step for advection. | . | Running Code: After setting the parameters mentioned above, run the code. The code will visualize the velocity data on the surface, forward advection \\(t0\\to tf\\) and backward advection \\(tf \\to t0\\) of tracer particles. This will be saved in the ./SaveResults folder. The deformation information will be displayed as a MATLAB plot using the code written in %% Calculate and Visualize the FTLE values. | . ",
    "url": "/docs/Tutorials/FTLECurvedSurface.html#performing-lagrangian-analysis",
    
    "relUrl": "/docs/Tutorials/FTLECurvedSurface.html#performing-lagrangian-analysis"
  },"5": {
    "doc": "FTLE on Curved Surfaces",
    "title": "FTLE on Curved Surfaces",
    "content": "The MATLAB code for computing Coherent Structures based on Finite-Time-Lyapunov Exponents (FTLE) and Lagrangian deformation for flow on curved surfaces is available at this link. The following tutorial provides instructions on how to use the code. To understand the mathematical background or additional information on the methods discussed here, we refer you to the accompanying manuscript S. Santhosh, C. Zhu, B. Fencil, M. Serra. [NEED TO WRITE THAT \\LAMBDA IS THE FTLE. SIMILAR FOR \\LAMBDAISO. YOU CAN ADD A PLOT LEGEND SOMEWHERE UP HERE] . Please contact us if you encounter any issues with the code, and we will work with you to fix the problem and make it work with your dataset. ",
    "url": "/docs/Tutorials/FTLECurvedSurface.html",
    
    "relUrl": "/docs/Tutorials/FTLECurvedSurface.html"
  },"6": {
    "doc": "FTLE on 2-D and 3-D Euclidean Space Using velocity data",
    "title": "FTLE on 2-D and 3-D Euclidean Space Using velocity data",
    "content": "Under construction. ",
    "url": "/docs/Tutorials/FTLEEuclidean.html",
    
    "relUrl": "/docs/Tutorials/FTLEEuclidean.html"
  },"7": {
    "doc": "FTLE on 2-D and 3-D Euclidean Space Using Sparse Trajectories",
    "title": "FTLE on 2-D and 3-D Euclidean Space Using Sparse Trajectories",
    "content": "The Python code for computing FTLE using the noisy and sparse trajectories are given in source. The functions HyperbolicLCS_2D and HyperbolicLCS_3D computes FTLE from sparse trajectories in 2D and 3D flow data. To understand the mathematical background or additional information on the methods discussed here, we refer you to the accompanying manuscript S. Molawi, M.Serra, E. Maiorino, L. Mahadevan (J. Fluid Mech. 2023). ",
    "url": "/docs/Tutorials/FTLESparseTrajectories.html",
    
    "relUrl": "/docs/Tutorials/FTLESparseTrajectories.html"
  },"8": {
    "doc": "FTLE in Active Nematics",
    "title": "FTLE in Active Nematics",
    "content": "There a growing corpus of literature highlights the role of LCS structures identified using FTLE methods in active flows, primarily in active nematic flow. We list some of the recent developements and must-reads so that you can get a sense of where it has been applied and how it is interpreted and how it has physical significance. | Defect-mediated dynamics of coherent structres in active nematics : This work from M. Serra et al, introduces the concept of LCS into analyzing the flows generated in active flows generated by active nematic systems. The paper goes on to analyze and correlate the motion of the LCS structures and couples it to the nematic orientational field. The paper also highlights the role of topological defects in generating the motion of these strutures. | . ",
    "url": "/docs/FTLEinActiveSystems.html",
    
    "relUrl": "/docs/FTLEinActiveSystems.html"
  },"9": {
    "doc": "FTLE in Biological Flows",
    "title": "FTLE in Biological Flows",
    "content": "There a growing corpus of literature highlights the role of LCS structures identified using FTLE methods in biological flows, primarily in morphogenesis. We list some of the recent developements and must-reads so that you can get a sense of where it has been applied and how it is interpreted and how it has biological significance. | Dynamic Morphoskeletons in Development : This work from M. Serra et al, introduces the concept of LCS into analyzing the flows generated in morphogenetic flows during Chick and Drosophila gastrulation. The paper also goes through concepts of why FTLE based methods are ideal to uncover hidden structure in the flow. | A multimodal zebrafish developmental atlas reveals the state-transition dynamics of late-vertebrate pluripotent axial progenitors : In collaboration with Royer Lab at CZ biohub, the fate specfication of NMP progenitor cells are analyzed from the perspective of morphogenetic flows. FTLE analysis reveals the emergence of a transport barrier between the PSM and the neural tube restricting the NMP population to PSM fate at later stages. | Control of epiblast cell fate by mechanical cues: Add details . | . ",
    "url": "/docs/FTLEinBiology.html",
    
    "relUrl": "/docs/FTLEinBiology.html"
  },"10": {
    "doc": "Tutorial - FTLE codes",
    "title": "Tutorial - FTLE codes",
    "content": "There are quite many codes developed to compute different FTLE for flows on different geometries. We will now provide a one-stop solution and tutorial for all your FTLE needs, whether your flow is in 2-D/3-D Euclidean space or on a curved surface in 3-D. ",
    "url": "/docs/TutorialFTLECode.html",
    
    "relUrl": "/docs/TutorialFTLECode.html"
  },"11": {
    "doc": "Introduction",
    "title": "What are Coherent Structures?",
    "content": "Coherent Structures are persistent, robust structures in a flow that summarize complex fluid trajectories and material deformations [1]. Lagrangian Coherent Structures (LCSs) [1] summarize material transport over a finite time interval. Eulerian Coherent Structures [2], on the other hand, do so over short-time intervals. Different methods have been proposed in the literature to compute these structures from flow data (see e.g. [3]). Here, we adopt Coherent Structures based on the Finite Time Lyapunov Exponent (FTLE) and instantaneous Lyapunov Exponents [4] fields, which are the most common due to their simplicity and straightforward visualization. The FTLE is computed from the Lagrangian deformation generated by the flow and is objective; i.e., it is invariant to time-dependent rotations and translations of the coordinate system used to describe motion. [NEED TO MODIFY THE FIGURE AND ADD INSTANTANEOUS ATTRACTORS / NAT COMM] . (a) Attracting and Repelling LCSs are special material surfaces in 3D flows, or curves in 2D flows, that maximally attract or repel nearby tracer particles. (b) Examples of flow which has been analyzed using the LCS framework. ",
    "url": "/#what-are-coherent-structures",
    
    "relUrl": "/#what-are-coherent-structures"
  },"12": {
    "doc": "Introduction",
    "title": "Why is coherent structure identification useful?",
    "content": "The FTLE helps identify the finite-time analogues of the stable and unstable manifolds which are called hyperbollic coherent structures, thereby providing a reduced representation of a temporally and spatially varying flow (See panel (a) in figure above). The reduced representation therefore enables a systematic comparison between flows in different experimental setups and with different theoretical model of the flow. Coherent structures also provides a simplified understanding of the flow geometry, which aids in the study of funtion of flows generated, such as in morphogenesis where material transport is important. Though FTLE was developed to analyze atmospheric and oceanic flows, recent work have demonstrated the usefulness of analyzing active flows generated by biological systems through a coherent structures framework (See panel (b) in figure above). See the link for a detailed list of papers using the ideas of coherent structures in addressing questions in biology. Simarly the there has been recent advances in understanding active nematic systems using flow structures (See link for a list of papers), which we expect to increase going forward. ",
    "url": "/#why-is-coherent-structure-identification-useful",
    
    "relUrl": "/#why-is-coherent-structure-identification-useful"
  },"13": {
    "doc": "Introduction",
    "title": "How do we calculate FTLE?",
    "content": "We will now describe how to compute the FTLE for a 2D flow described by the velocity field \\(\\mathbf{v}(\\mathbf{x},t)\\) were \\(\\mathbf{x},\\mathbf{v} \\in \\mathbb{R}^2\\). The formalism required to compute FTLE for flows on 2D curved surfaces embedded in 3D is different and we refer you to the paper S. Santhosh et al for details. In general, to experimentally compute the velocity field of a flow PIV methods are used (See Ref, PIVLab is a MATLAB toolbox to easily compute PIV). To study the Lagrangian features of the flow, we compute the flow map . $$ \\mathbf{F}_{t_0}^t(\\mathbf{x}_0) = \\mathbf{x}_0 + \\int_{t_0}^t \\mathbf{v}(\\mathbf{F}_{t_0}^\\tau(\\mathbf{x}_0),\\tau) d\\tau. $$ The FTLE is computed using the right Cauchy-Green strain tensor \\(\\mathbf{C}_{t_0}^t(\\mathbf{x}_0) = (\\mathbf{\\nabla}_{\\mathbf{x}_0}\\mathbf{F}_{t_0}^t(\\mathbf{x}_0))^\\top(\\mathbf{\\nabla}_{\\mathbf{x}_0}\\mathbf{F}_{t_0}^t(\\mathbf{x}_0)),\\) which quantifies the Lagrangian deformation experienced by a material patch initially at \\(\\mathbf{x}_0\\) over the time-interval \\([t_0,t]\\). The eigenvalues of the \\(\\mathbf{C}_{t_0}^t(\\mathbf{x}_0)\\) are positive, since it is real and symmetric. The FTlE field is given by, . $$ \\Lambda_{t_0}^t(\\mathbf{x}_0) = \\frac{1}{2|t-t_0|}\\text{log}(\\lambda_2),$$ where \\(\\lambda_2\\) is the largest eigenvalue of \\(\\mathbf{C}_{t_0}^t(\\mathbf{x}_0)\\). ",
    "url": "/#how-do-we-calculate-ftle",
    
    "relUrl": "/#how-do-we-calculate-ftle"
  },"14": {
    "doc": "Introduction",
    "title": "References",
    "content": "[1] : Haller, G., 2015. Lagrangian coherent structures. Annual review of fluid mechanics, 47(1) . [2] : Serra, M., &amp; Haller, G. (2016). Objective Eulerian coherent structures. Chaos: An Interdisciplinary Journal of Nonlinear Science, 26(5) . [3] : Hadjighasem, A., Farazmand, M., Blazevski, D., Froyland, G., &amp; Haller, G. (2017). A critical comparison of Lagrangian methods for coherent structure detection. Chaos: An Interdisciplinary Journal of Nonlinear Science, 27(5). [4] : Nolan, P. J., Serra, M., &amp; Ross, S. D. (2020). Finite-time Lyapunov exponents in the instantaneous limit and material transport. Nonlinear Dynamics, 100(4), 3825-3852. ",
    "url": "/#references",
    
    "relUrl": "/#references"
  },"15": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"16": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "Installation",
    "content": "To install the python package you can use the following command in your python environment: . pip install -e git+https://github.com/bfencil/ftlePackage.git#egg=ftlePackage . This pacakge was made in python version 3.11.8. ",
    "url": "/docs/Tutorials/pythonPackage.html#installation",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html#installation"
  },"17": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "Dense FTLE Computations in $\\mathbb{R}^2$ and $\\mathbb{R}^3$",
    "content": "Overview . The dense FTLE codes differ from the sparse FTLE codes in that the initial particle positions are set on a uniform grid that spans the entire domain. This is opposed to the sparse FTLE codes where particles are placed arbitrarily in space. This uniform grid structure is useful when: . | A global picture of the entire velocity field is desired. | The velocity data itself is sparse but the user wants a continuous FTLE field. | It simplifies the FTLE computation using finite-difference schemes. | . The primary functions of interest for dense FTLE computations are: . | FTLE_2d_dense â€” for dense FTLE computation in $\\mathbb{R}^2$. | FTLE_3d_dense â€” for dense FTLE computation in $\\mathbb{R}^3$. | . Example Usage . A typical workflow using FTLE_2d_dense looks like this: . from ftle.flat.dense import FTLE_2d_dense ftle_values, trajectories = FTLE_2d_dense( velocity_points, velocity_vectors, x_grid, y_grid, dt, initial_time, final_time, time_steps, direction, time_indepedent=False, plot_ftle=True ) . Inputs for FTLE_2d_dense . | velocity_points: (M, 2) array of the known locations where velocity data is given. | velocity_vectors: (M, 2) if time-independent or (M, 2, T) if time-dependent velocity vectors. | x_grid: 2D array of X positions from np.meshgrid. | y_grid: 2D array of Y positions from np.meshgrid. | dt: Float, time step size for RK4 integration. Must have $0 &lt; dt \\leq 1$. | initial_time: Starting time index. | final_time: Ending time index. | time_steps: List of available time steps. | direction: String \"forward\" or \"backward\". | time_indepedent: Boolean, if True uses static velocity field. | plot_ftle: Boolean, if True plots the FTLE field directly. | . Inputs for FTLE_3d_dense . Very similar to FTLE_2d_dense but adapted for 3D. from ftle.flat.dense import FTLE_3d_dense ftle_values, trajectories = FTLE_3d_dense( velocity_points, velocity_vectors, x_grid, y_grid, z_grid, dt, initial_time, final_time, time_steps, direction, time_indepedent=False, plot_ftle=True ) . Inputs . | x_grid, y_grid, z_grid: 3D arrays from np.meshgrid. | All other inputs are the same as FTLE_2d_dense. | . FTLE Computation Methodology . The FTLE computation for dense grids uses a finite difference scheme to compute the deformation gradient tensor $\\partial X_f / \\partial X_0$. | For 2D: This is done in FTLE_2d_compute. | For 3D: This is done in FTLE_3d_compute. | . Both methods: . | Use central differences across the local grid. | Build the deformation gradient $F$. | Compute the Cauchy-Green strain tensor $C = F^T F$. | Extract the largest eigenvalue of $C$. | Compute FTLE as: | . \\[\\text{FTLE} = \\frac{1}{2 |t_f - t_i|} \\ln(\\sqrt{\\lambda_{max}})\\] where $\\lambda_{max}$ is the largest eigenvalue of $C$. Notes on Usage . | The uniform grid from np.meshgrid must fully cover the desired domain. | For plotting FTLE: | . from ftle.flat.utilities import plot_FTLE_2d, plot_FTLE_3d . | The plotting functions will automatically scatter the FTLE values over the grid points. | In 3D, the plotting shows the full 3D cloud of points and also provides 2D slices along the $XZ$ plane at select $Y$ values. | . Example FTLE Plot in 2D . plot_FTLE_2d(particles_positions, ftle) . Place example here! â€” . Example FTLE Plot in 3D . plot_FTLE_3d(particles_positions, ftle) . Place example here! â€” . ",
    "url": "/docs/Tutorials/pythonPackage.html#dense-ftle-computations-in-mathbbr2-and-mathbbr3",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html#dense-ftle-computations-in-mathbbr2-and-mathbbr3"
  },"18": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "Sparse FTLE Computations in $\\mathbb{R}^2$ and $\\mathbb{R}^3$",
    "content": "Overview . The sparse FTLE routines are designed to work with velocity fields that are defined only at scattered locations in space. These methods do not require a grid or mesh. Instead, they interpolate the velocity field from known velocity locations and compute FTLE from particle trajectories. Sparse FTLE computations are especially useful when: . | Your velocity field is only known at irregular points (experimental data, scattered sensors). | You want to avoid gridding or meshing overhead. | . Sparse FTLE methods rely on KD-Trees and least-squares estimation of the deformation gradient using nearest-neighbor points. ",
    "url": "/docs/Tutorials/pythonPackage.html#sparse-ftle-computations-in-mathbbr2-and-mathbbr3",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html#sparse-ftle-computations-in-mathbbr2-and-mathbbr3"
  },"19": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "Available Functions",
    "content": ". | FTLE_2d_sparse : Sparse FTLE calculation for 2D velocity fields. | FTLE_3d_sparse : Sparse FTLE calculation for 3D velocity fields. | compute_Ftle_sparse : Computes FTLE values given only initial and final particle positions. | plot_FTLE_2d : Visualization for 2D FTLE. | plot_FTLE_3d : Visualization for 3D FTLE with optional slicing. | . ",
    "url": "/docs/Tutorials/pythonPackage.html#available-functions",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html#available-functions"
  },"20": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "Example Usage: FTLE_2d_sparse",
    "content": "from ftle.flat.sparse import FTLE_2d_sparse ftle_values, trajectories = FTLE_2d_sparse( velocity_points, # (M, 2) array of known velocity locations velocity_vectors, # (M, 2) or (M, 2, T) array of velocity vectors particle_positions, # (N, 2) array of initial particle positions dt=0.1, # Integration time step (0 &lt; dt &lt;= 1) initial_time=0, final_time=10, time_steps=np.arange(0, 11), direction='forward', time_indepedent=False, plot_ftle=True, neighborhood=10 ) . ",
    "url": "/docs/Tutorials/pythonPackage.html#example-usage-ftle_2d_sparse",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html#example-usage-ftle_2d_sparse"
  },"21": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "Inputs for FTLE_2d_sparse and FTLE_3d_sparse",
    "content": ". | velocity_points Array of shape (M, d) where d=2 or 3. These are the known locations of the velocity data. | velocity_vectors Array of shape (M, d) if the velocity is time-independent, or (M, d, T) if time-dependent. | particle_positions Initial positions of particles, of shape (N, d). | dt Time step size for integration. Must satisfy 0 &lt; dt &lt;= 1. | initial_time and final_time Integers specifying start and end time steps for the advection. | time_steps Array of allowed time steps (must be consecutive integers starting from 0). | direction Either \"forward\" or \"backward\" advection. | time_indepedent Boolean. If True, velocity field is assumed to be time-invariant. | plot_ftle Boolean. If True, generates a plot of the FTLE field. | neighborhood Integer. Number of nearest neighbors to use when computing FTLE values. | lam Small regularization constant (default $1 \\times 10^{-10}$) for stability. | . ",
    "url": "/docs/Tutorials/pythonPackage.html#inputs-for-ftle_2d_sparse-and-ftle_3d_sparse",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html#inputs-for-ftle_2d_sparse-and-ftle_3d_sparse"
  },"22": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "FTLE Computation via compute_Ftle_sparse",
    "content": "The function compute_Ftle_sparse can be used directly if you have only the initial and final positions of particles, this works for both d=2,3. from ftle.flat.sparse import compute_Ftle_sparse ftle_values = compute_Ftle_sparse( initial_positions, # (N, d) final_positions, # (N, d) initial_time, final_time, k=10 # Number of nearest neighbors for FTLE computation ) . ",
    "url": "/docs/Tutorials/pythonPackage.html#ftle-computation-via-compute_ftle_sparse",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html#ftle-computation-via-compute_ftle_sparse"
  },"23": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "Surfaces in $\\mathbb{R}^3$",
    "content": "Overview . This section provides functionality for computing FTLE (Finite Time Lyapunov Exponent) fields for flows on triangulated surfaces in $\\mathbb{R}^3$. This is distinct from the dense and sparse FTLE methods in Euclidean domains, as here the mesh itself evolves over time and particles are constrained to remain on the surface throughout the advection process. The primary function for users is FTLE_mesh, which wraps the entire process of particle advection and FTLE computation for a triangulated, staggered mesh surface. Additional functions such as FTLE_compute are available if finer control is needed (e.g. using your own advection scheme or particle data). Example Usage . The function FTLE_mesh uses the input mesh data with a defined vector field data for the mesh to advect particles constrained to the mesh and to compute the FTLE values at each initial particle position. The mesh does not need any specific structure and the mesh itself can move over time and have a different number of nodes per time step. The advection scheme used is a standard RK4 scheme and KDtrees are used to assist in the projecting particles down to the surface after each time step. It is worth noting that due to the general design of FTLE_mesh to work with meshes that are not well defined over time(different number of nodes per time step), the RK4 integration time step is just set to \\(dt=1\\)(i.e the assumed difference between time steps in the mesh data). FTLE_mesh returns the FTLE data along with the trajectory data. Also FTLE_mesh has built in plotting functionality in a function plot_FTLE_mesh which is discussed more in a later section. from ftle.curved.mesh import ftle_mesh ftle_values , trajectories = def FTLE_mesh( node_connections, # List[np.ndarray], each (M_t, 3) node_positions, # List[np.ndarray], each (N_t, 3) node_velocities, # List[np.ndarray], each (N_t, 3) particle_positions, # (P, 3) initial_time, # int final_time, # int time_steps, # (T,) direction=\"forward\", # \"forward\" or \"backward\" plot_ftle=False, # If True, calls plot_ftle_mesh save_path = None, camera_setup = None, neighborhood=15, # For FTLE computation lam=1e-10 # Regularization ): . Inputs for ftle_mesh . The ftle_mesh function computes the FTLE field for flows on a triangulated surface in $\\mathbb{R}^3$. It takes the following inputs: . | node_cons A list of arrays of shape (M_t, 3) for each time step. Each array describes the mesh connectivity at that time step, where M_t is the number of faces at time t. | node_positions A list of arrays of shape (N_t, 3) for each time step, where N_t is the number of nodes at time t. These are the spatial coordinates of the mesh nodes. | node_velocities A list of arrays of shape (N_t, 3) for each time step. These are the velocity vectors at each node. | particle_positions An array of shape (P, 3) containing the initial positions of the particles to advect on the surface, where P is the number of particles, for ease of plotting the final results it is recommended that the initial positions just correspond to the node positions at the initial time. | initial_time An integer specifying the starting time index for the advection. This must respect final time with respect to the direction(â€˜forwardâ€™/â€™backwardâ€™) i.e if direction is â€˜backwardâ€™ then initial_time $&gt;$ final_time. Just reverse the inequality for â€˜forwardâ€™. | final_time An integer specifying the ending time index for the advection. This must respect final time with respect to the direction(â€˜forwardâ€™/â€™backwardâ€™) i.e if direction is â€˜backward then initial_time $&gt;$ final_time. Just reverse the inequality for â€˜forwardâ€™. | time_steps An array of time values corresponding to the available mesh data which should be orgainized as consecutive integers starting at 0. | direction A string, either \"forward\" or \"backward\" indicating the direction of advection. | plot_ftle Optional boolean. If True, automatically generates a 3D PyVista plot of the FTLE field. This does not save the plot. | save_path Optional string. If plot_ftle is true then having a save path specified will save the 3d plot in that directory. Take note that if a save path is given the PyVista plotting window will not appear due to PyVista plots having to be saved off screen. | camera_setup Optional tuple: (camera position, focal point, camera roll). | neighborhood Integer (default 15). The number of nearest neighboring particles used when computing the local FTLE gradient. | lam Regularization parameter (default $1 \\times 10^{-10}$). Helps stabilize the least-squares fit of the deformation gradient in regions with near-linear configurations. | . Inputs for FTLE_compute . The FTLE_compute function computes FTLE values directly given initial and final particle positions. It can be imported directly from ftle.curved.mesh import FTLE_compute This is useful if: . | You already have your own particle trajectories(like what is returned from ftle_mesh). | You want to bypass ftle_mesh and just compute FTLE. | . Here are the expected inputs . ftle.curved.mesh import FTLE_compute ftle_values = def FTLE_mesh( node_connections, # List[np.ndarray], each (M_t, 3) node_positions, # List[np.ndarray], each (N_t, 3) node_velocities, # List[np.ndarray], each (N_t, 3) particle_positions, # (P, 3) initial_time, # int final_time, # int time_steps, # (T,) direction=\"forward\", # \"forward\" or \"backward\" plot_ftle=False, # If True, calls plot_ftle_mesh save_path = None, camera_setup = None, neighborhood=15, # For FTLE computation lam=1e-10 # Regularization ): . | node_cons A list of arrays of shape (M_t, 3) for each time step. Each array describes the mesh connectivity at that time step, where M_t is the number of faces at time t. | node_positions A list of arrays of shape (N_t, 3) for each time step, where N_t is the number of nodes at time t. These are the spatial coordinates of the mesh nodes. | centroids A list of arrays of triangle centroids for each time step. These can be generated using the helper function compute_centroids_staggered. | initial_positions A (P, 3) array containing the positions of particles at the initial time step. | final_positions A (P, 3) array containing the positions of particles at the final time step. | initial_time Integer index specifying the start time. | final_time Integer index specifying the end time. | neighborhood The number of neighboring particles to use for local FTLE estimation. Defaults to 15. | lam A small regularization constant (default $1 \\times 10^{-10}$) used to stabilize the inversion of matrices during gradient estimation. | . Inputs for plot_FTLE_mesh . The plot_FTLE_mesh function can be called directly by importing it from ftle.curved.utilities import plot_FTLE_mesh. Here are the expected inputs: . from ftle.curved.utilities import plot_FTLE_mesh def plot_FTLE_mesh( node_cons, node_positions, initial_time, final_time, ftle, direction, save_path=None, # Optional: str or None camera_setup=None # Optional: tuple (position, focal_point, roll) ): . | node_cons A list of arrays of shape (M_t, 3) for each time step. Each array describes the mesh connectivity at that time step, where M_t is the number of faces at time t. | node_positions A list of arrays of shape (N_t, 3) for each time step, where N_t is the number of nodes at time t. These are the spatial coordinates of the mesh nodes. | initial_time An integer specifying the starting time index for the advection. This must respect final time with respect to the direction(â€˜forwardâ€™/â€™backwardâ€™) i.e if direction is â€˜backwardâ€™ then initial_time $&gt;$ final_time. Just reverse the inequality for â€˜forwardâ€™. | final_time An integer specifying the ending time index for the advection. This must respect final time with respect to the direction(â€˜forwardâ€™/â€™backwardâ€™) i.e if direction is â€˜backward then initial_time $&gt;$ final_time. Just reverse the inequality for â€˜forwardâ€™. | ftle A one dimensional list corresponding to the amount of nodes at time, initial_time. | direction A string, either \"forward\" or \"backward\" indicating the direction of advection. | save_path Optional string. If plot_ftle is true then having a save path specified will save the 3d plot in that directory. Take note that if a save path is given the PyVista plotting window will not appear due to PyVista plots having to be saved off screen. | camera_setup Optional tuple: (camera position, focal point, camera roll). | . When no save_path is specified then you can press â€˜câ€™ in the PyVista plotting window to display needed information to specifiy camera_setup with respect to your current camera view in the PyVista plotting window. Example plot_FTLE_mesh directly . from ftle.curved.mesh import FTLE_mesh from ftle.curved.utilities import plot_FTLE_mesh import h5py def load_mesh_data_h5(h5_file_path): \"\"\" Load staggered curved surface mesh data from an HDF5 file. Expects groups: /node_cons/{t} /position/{t} /velocity/{t} /time_steps Returns dict with lists of per-time-step arrays. \"\"\" with h5py.File(h5_file_path, 'r') as f: time_steps = f[\"time_steps\"][:] total_time = len(time_steps) # Convert string keys to sorted integers keys = sorted(f[\"position\"].keys(), key=lambda k: int(k)) position = [f[\"position\"][k][:] for k in keys] velocity = [f[\"velocity\"][k][:] for k in keys] node_cons = [f[\"node_cons\"][k][:] for k in keys] # Sanity check assert len(position) == total_time, \"Mismatch in position data and time_steps\" assert len(velocity) == total_time assert len(node_cons) == total_time return { 'node_cons': node_cons, # list of (M_t, 3) 'position': position, # list of (N_t, 3) 'velocity': velocity, # list of (N_t, 3) 'time_steps': time_steps, 'node_number': [p.shape[0] for p in position], # list of node counts per step 'total_time': total_time } file_path = f'dataHeart.h5' mesh_data = load_mesh_data_h5(file_path) node_positions = mesh_data['position'] node_velocities = mesh_data['velocity'] time_steps = mesh_data['time_steps'] node_cons = mesh_data['node_cons'] direction = \"forward\" initial_time = 0 final_time = 5 particle_positions = node_positions[initial_time] for_ftle, for_trajectories = FTLE_mesh(node_cons, node_positions, node_velocities, particle_positions, initial_time, final_time, time_steps, direction, plot_ftle=True, neighborhood=10) plot_FTLE_mesh(node_cons, node_positions, initial_time, final_time, for_ftle, direction, save_path=\"my_plot1.png\", camera_setup=((130.4046, -178.1839, -1312.8635), (379.1223, 531.1033, 147.2741), -152.84 ) ) direction = \"backward\" initial_time = 28 final_time = 0 particle_positions = node_positions[initial_time] back_ftle, back_trajectories = FTLE_mesh(node_cons, node_positions, node_velocities, particle_positions, initial_time, final_time, time_steps, direction, plot_ftle=True, neighborhood=10) plot_FTLE_mesh(node_cons, node_positions, initial_time, final_time, back_ftle, direction, save_path=\"my_plot2.png\", camera_setup=((130.4046, -178.1839, -1312.8635), (379.1223, 531.1033, 147.2741), -152.84 ) ) . The data in the .h5 file is for a Zrebra fish heart and for the given time have the following FTLE field: . ",
    "url": "/docs/Tutorials/pythonPackage.html#surfaces-in-mathbbr3",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html#surfaces-in-mathbbr3"
  },"24": {
    "doc": "FTLE on Curved Surfaces - Python Implementation",
    "title": "FTLE on Curved Surfaces - Python Implementation",
    "content": "The python package for computing the coherent structures and Lagrangian deformation for flow on a curved surface is given in this link. To understand the mathematical background or additional information on the methods discussed here, we refer you to the accompanying manuscript S. Santhosh et al. ",
    "url": "/docs/Tutorials/pythonPackage.html",
    
    "relUrl": "/docs/Tutorials/pythonPackage.html"
  }
}
